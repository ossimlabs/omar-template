import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

buildscript {
	repositories {
		maven { url System.getenv('MAVEN_REPO_URL') }
		maven { url "https://repo.grails.org/grails/core" }
	}
	dependencies {
		classpath "org.grails:grails-gradle-plugin:$grailsVersion"
		classpath "org.grails.plugins:hibernate5:${ hibernate5PluginVersion }"
		classpath "gradle.plugin.com.github.erdi.webdriver-binaries:webdriver-binaries-gradle-plugin:${ webdriverPluginVersion }"
		classpath "com.bertramlabs.plugins:asset-pipeline-gradle:3.0.10"
	}
}

plugins {
	id "com.github.ben-manes.versions" version "0.21.0"
	id 'com.bmuschko.docker-remote-api' version '4.10.0'
}


subprojects { project ->
	
	boolean isGrailsApp = project.name.endsWith( '-app' )
	boolean isGrailsPlugin = project.name.endsWith( '-plugin' )
	boolean isGrailsProject = isGrailsApp || isGrailsPlugin
		
	version projectVersion
	group groupName
	
	apply plugin: "eclipse"
	apply plugin: "idea"
	
	afterEvaluate {
		project.apply plugin: 'maven-publish'
		
		project.publish.dependsOn assemble
		project.publishToMavenLocal.dependsOn assemble
		
		project.publishing {
			repositories {
				maven {
					url = System.getenv( 'MAVEN_PUBLISH_URL' )
					credentials {
						username System.getenv( 'MAVEN_REPO_USERNAME' )
						password System.getenv( 'MAVEN_REPO_PASSWORD' )
					}
				}
			}
			publications {
				mavenJava( MavenPublication ) {
					from components.java
				}
			}
		}
	}
	
	if ( isGrailsProject )
	{
		if ( isGrailsApp )
		{
			apply plugin: "org.grails.grails-web"
			apply plugin: "com.github.erdi.webdriver-binaries"
			apply plugin: "org.grails.grails-gsp"
			apply plugin: "com.bertramlabs.asset-pipeline"
			
			apply plugin: 'com.bmuschko.docker-remote-api'
			apply plugin: com.bmuschko.gradle.docker.DockerRemoteApiPlugin
		}
		else if ( isGrailsPlugin )
		{
			apply plugin: "eclipse"
			apply plugin: "idea"
			apply plugin: "org.grails.grails-plugin"
			apply plugin: "org.grails.grails-plugin-publish"
			apply plugin: "asset-pipeline"
			apply plugin: "org.grails.grails-gsp"
		}
		
		repositories {
			mavenLocal()
			maven { url System.getenv('MAVEN_REPO_URL') }
			maven { url "https://repo.grails.org/grails/core" }
		}
		
		configurations {
			developmentOnly
			runtimeClasspath {
				extendsFrom developmentOnly
			}
		}
		
		dependencyManagement {
			imports {
				mavenBom "org.springframework.cloud:spring-cloud-dependencies:${ springCloudVersion }"
			}
		}
		
		dependencies {
			developmentOnly( "org.springframework.boot:spring-boot-devtools" )
			compile "org.springframework.boot:spring-boot-starter-logging"
			compile "org.springframework.boot:spring-boot-autoconfigure"
			compile "org.grails:grails-core"
			compile "org.springframework.boot:spring-boot-starter-actuator"
			compile "org.springframework.boot:spring-boot-starter-tomcat"
			compile "org.grails:grails-web-boot"
			compile "org.grails:grails-logging"
			compile "org.grails:grails-plugin-rest"
			compile "org.grails:grails-plugin-databinding"
			compile "org.grails:grails-plugin-i18n"
			compile "org.grails:grails-plugin-services"
			compile "org.grails:grails-plugin-url-mappings"
			compile "org.grails:grails-plugin-interceptors"
			compile "org.grails.plugins:cache"
			compile "org.grails.plugins:async"
			compile "org.grails.plugins:scaffolding"
			compile "org.grails.plugins:gsp"
			compileOnly "io.micronaut:micronaut-inject-groovy"
			console "org.grails:grails-console"
			runtime "com.bertramlabs.plugins:asset-pipeline-grails:${ assetPipelineVersion }"
			testCompile "org.grails:grails-gorm-testing-support"
			testCompile "org.mockito:mockito-core"
			testCompile "org.grails:grails-web-testing-support"
			
			if ( isGrailsApp )
			{
				compile "org.grails.plugins:events"
				compile "org.grails.plugins:hibernate5"
				compile "org.hibernate:hibernate-core:${ hibernateCoreVersion }"
				profile "org.grails.profiles:web"
				runtime "org.glassfish.web:el-impl:${ glassfishVersion }"
				runtime "com.h2database:h2"
				runtime "org.apache.tomcat:tomcat-jdbc"
				runtime "javax.xml.bind:jaxb-api:${ jaxbApiVersion }"
				testCompile "org.grails.plugins:geb"
				testCompile "org.seleniumhq.selenium:selenium-remote-driver:${ seleniumVersion }"
				testCompile "org.seleniumhq.selenium:selenium-api:${ seleniumVersion }"
				testCompile "org.seleniumhq.selenium:selenium-support:${ seleniumVersion }"
				testRuntime "org.seleniumhq.selenium:selenium-chrome-driver:${ seleniumVersion }"
				testRuntime "org.seleniumhq.selenium:selenium-firefox-driver:${ seleniumVersion }"
				
				compile "org.springframework.cloud:spring-cloud-starter-config"
				compile "org.springframework.cloud:spring-cloud-starter-netflix-eureka-client"
			}
			else if ( isGrailsPlugin )
			{
				profile "org.grails.profiles:web-plugin"
				//testCompile "org.grails:grails-plugin-testing"
			}
		}
		
		bootRun {
			jvmArgs(
				'-Dspring.output.ansi.enabled=always',
				'-noverify',
				'-XX:TieredStopAtLevel=1',
				'-Xmx1024m' )
			sourceResources sourceSets.main
			String springProfilesActive = 'spring.profiles.active'
			systemProperty springProfilesActive, System.getProperty( springProfilesActive )
		}
		
		if ( isGrailsApp )
		{
			webdriverBinaries {
				chromedriver '2.45.0'
				geckodriver '0.24.0'
			}
			
			tasks.withType( Test ) {
				systemProperty "geb.env", System.getProperty( 'geb.env' )
				systemProperty "geb.build.reportsDir", reporting.file( "geb/integrationTest" )
				systemProperty "webdriver.chrome.driver", System.getProperty( 'webdriver.chrome.driver' )
				systemProperty "webdriver.gecko.driver", System.getProperty( 'webdriver.gecko.driver' )
			}
		}
		else if ( isGrailsPlugin )
		{
			// enable if you wish to package this plugin as a standalone application
			bootJar.enabled = false
			grailsPublish {
				// TODO: Provide values here
				user = 'user'
				key = 'key'
				githubSlug = 'foo/bar'
				license {
					name = 'Apache-2.0'
				}
				title = "My Plugin"
				desc = "Full plugin description"
				developers = [ johndoe: "John Doe" ]
			}
		}
		
		assets {
			if ( isGrailsApp )
			{
				minifyJs = true
				minifyCss = true
			}
			else if ( isGrailsPlugin )
			{
				packagePlugin = true
			}
		}
	}
	
	if ( isGrailsApp )
	{
		ext {
			dockerRegistry = System.getenv( 'DOCKER_REGISTRY_URL' ).split( '/' )[0] // project.dockerRegistry
			dockerRepo = System.getenv( 'DOCKER_REGISTRY_URL' ).split( '/' )[1]  //project.dockerRepo
			dockerTag = "${ project.name }:${ project.version }".toLowerCase()
			dockerBuildDir = mkdir( "${ project.buildDir }/docker" )
		}
		
		task prepareDocker( type: Copy, dependsOn: assemble ) {
			description = 'Copy files from src/main/docker and application jar to Docker temporal build directory'
			group = 'Docker'
			
			from 'src/main/docker'
			from project.jar
			
			into dockerBuildDir
		}
		
		task createDockerfile( type: Dockerfile, dependsOn: prepareDocker ) {
			description = 'Create a Dockerfile file'
			group = 'Docker'
			
			destFile = project.file( "${ dockerBuildDir }/Dockerfile" )
			
			from 'openjdk:8-jdk-alpine'
			
			label( [
				maintainer: 'John Doe "john.doe@example.com"'
			] )
			
			exposePort 8080
			
			workingDir '/app'
			
			copyFile jar.archiveName, 'application.jar'
			copyFile 'app-entrypoint.sh', 'app-entrypoint.sh'
			runCommand 'chmod +x app-entrypoint.sh'
			
			//	entryPoint '/app/app-entrypoint.sh'
			defaultCommand '/app/app-entrypoint.sh'
			
			onlyIf {
				!file( "${ projectDir }/src/main/docker/Dockerfile" ).exists()
			}
		}
		
		task buildImage( type: DockerBuildImage, dependsOn: createDockerfile ) {
			description = 'Create Docker image to run the Grails application'
			group = 'Docker'
			
			inputDir = file( dockerBuildDir )
			
			tags = [ "${ project.dockerTag }".toString() ]
		}
		
		task tagImage( type: DockerTagImage, dependsOn: buildImage ) {
			group = 'Docker'
			description = "Tag custom docker image."
			
			targetImageId buildImage.getImageId()
			
			repository = "${ dockerRegistry }/${ dockerRepo }/${ project.name }".toString()
			tag = projectVersion
		}
		
		docker {
			registryCredentials {
				url = dockerRegistry
				username = System.getenv( 'DOCKER_REGISTRY_USERNAME' )
				password = System.getenv( 'DOCKER_REGISTRY_PASSWORD' )
			}
		}
		
		task pushImage( type: DockerPushImage, dependsOn: tagImage ) {
			group = 'Docker'
			description = "Push custom docker image."
			
			tag = projectVersion
			imageName = "${ dockerRegistry }/${ dockerRepo }/${ project.name }".toString()
		}
		
		task openshiftLogin( type: Exec ) {
			doLast {
				commandLine 'oc',
					'login',
					openshiftUrl,
					'-u', System.getenv( 'OPENSHIFT_USERNAME' ),
					'-p', System.getenv( 'OPENSHIFT_PASSWORD' )
				
				if ( !dockerRegistryUrl.endsWith( '/' ) )
				{
					dockerRegistryUrl += '/'
				}
			}
		}
		
		task openshiftTagImage( type: Exec, dependsOn: 'openshiftLogin' ) {
			doLast {
				commandLine 'oc',
					'tag',
					'--source=docker',
					"${ dockerRegistryUrl }${ dockerImageName }:${ dockerImageTag }",
					"${ openshiftProjectName }/${ openshiftServiceName }:${ dockerImageTag }",
					'--scheduled=true'
			}
		}
	}
}
